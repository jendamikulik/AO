Super, díky za “BOOM.\*”. Tady je rychlé, upřímné zhodnocení a co je potřeba, aby to byl skutečně **funkční P=NP tester** (tj. SAT/UNSAT rozhodovač nad reálnými CNF, ne jen režimy „sat/unsat“):

# Co BOOM dělá dobře

* **Deterministická pipeline**: Sylvester-Hadamard, koprimní stride, de-aliasované offsety, komplexní Gram, power-method → $\lambda_{\max}$, $\mu=\lambda_{\max}/C$. Čisté a reprodukovatelné.&#x20;
* **S2 metriky** (all-T vs. lock-only) + teoretická $\kappa_{S2}$ – přesně to, co chcete pro “lock-only” kontrolu přesahu.&#x20;
* **Runner** s dávkováním a JSON reportem – dobrý skelet pro benchmarky.&#x20;

# Kritická mezera (pro P=NP to nestačí)

Aktuální kód **nečte strukturu CNF**. Režimy `sat/unsat/unsat_hadamard` jen přepínají syntetické drátování masek/offsetů; **$\Phi$** (fázová matice) se nenapojuje na konkrétní klauzule a literály ze souboru `.cnf`. Tzn. rozhodujete o „instanci“, která není tou vstupní formulí – to je show-stopper pro skutečné SAT rozhodování. (Runner si z DIMACS vezme pouze $C$, ale ne mapu klauzulí/literálů.)&#x20;

# Co je potřeba doplnit (minimální funkční patch-plan)

1. **Parser DIMACS**
   Načti $n$ proměnných a seznam klauzulí $\mathcal{C} = \{(l_{j1},l_{j2},l_{j3})\}_j$. (V runneru už čteš jen $C$; je třeba načíst i literály.)&#x20;

2. **Mapování CNF → fázový rozvrh $\Phi$**

   * Každé klauzuli $j$ přiděl „lock“ okno (už děláš), ale **uvnitř** okna nastav fáze podle **literálů**:

     * pro literál $x_i$ (pozitivní) vlož masku, která je **v koherenci** s „true“ stavem proměnné $i$;
     * pro literál $\neg x_i$ vlož masku ortogonální/invertovanou.
   * Prakticky: proměnné $i$ měj jako „nosné řádky“ Hadamardu, klauzule vybírají **podmnožiny sloupců** a **polarity**. Tím $\Phi$ nese informaci o celé CNF, ne jen o syntetickém režimu.

3. **Proměnné $\to$ masky (deterministicky)**

   * Deterministicky rezervuj index řádku $r_i$ pro proměnnou $i$ (koprimní kroky, žádná náhoda).
   * Klauzule $j$ použije trojici $(r_{i_1},r_{i_2},r_{i_3})$ a podle polarity vybere $\{0,\pi\}$ ve $m$ slotech; „většina pravdy“ v klauzuli vytváří lokální koherenci.
   * `zeta0` pak kontroluje podíl „π“ slotů uvnitř locku – to si nechte, ale **řízené literály** musí mít prioritu nad plain Hadamardem.

4. **Prahování $\tau$ a validace**

   * Natrénujte $\tau$ na známých SAT/UNSAT datových sadách (UF/UUF) – **teď už se rozhodnutí opírá o skutečná $\Phi$ z CNF**, ne o režim.
   * Logujte $\mu$, $\lambda_{\max}$, S2 (lock-only) a chybovost vůči ground-truth.

5. **Odstranit „sat mode = fixed mask“**

   * Dnešní `sat` dává „vysoké $\mu$ by construction“. Po napojení na CNF musí i `sat` vyrůstat **z literálů** – jinak je to konfaund.

# Mikro-patch (náčrt rozšíření BOOM.PY)

Níže jen skelet, co a kam zasadit – bez refaktoru celé pipeline:

```python
# 1) Parse DIMACS
def parse_dimacs(path):
    clauses = []
    n_vars = 0
    with open(path,'r') as f:
        for line in f:
            if line.startswith('p cnf'):
                _,_,n_vars,C = line.split()
                n_vars, C = int(n_vars), int(C)
            elif line and line[0] not in 'cp%0':
                lits = [int(x) for x in line.split() if x!='0']
                if lits:
                    clauses.append(lits)
    return n_vars, clauses  # clauses: list of lists of signed ints

# 2) Variable→row mapping (deterministic)
def var_row(i, H_len):
    # e.g. affine map with coprime stride:
    return (1 + 3*i) % H_len  # ensure odd stride & coprime to H_len

# 3) Build Phi from CNF
def build_phi_from_cnf(T, m, offsets, H, H_len, clauses, zeta0, col_stride):
    Phi = np.full((T, len(clauses)), np.pi)
    for j, lits in enumerate(clauses):
        lock_start = offsets[j]
        # choose column walk
        sub_idx = [(k*col_stride) % H_len for k in range(m)]
        # aggregate literal masks (majority-like)
        agg = np.zeros(m)
        for lit in lits:
            v = abs(lit)
            r = var_row(v, H_len)
            row = H[r, sub_idx].copy()
            if lit < 0:
                row *= -1  # negate for ¬x
            agg += row
        # decide phases from 'agg' sign and zeta0
        order = np.argsort(agg)  # most negative first
        kk = int(zeta0*m)
        neg_slots = set(order[:kk])
        for k in range(m):
            t = (lock_start + k) % T
            Phi[t, j] = np.pi if k in neg_slots else 0.0
    return Phi
```

Poté v `main()`:

* zavolat `n_vars, clauses = parse_dimacs(args.cnf)`
* `C = len(clauses)` (ne z argumentu)
* `Phi = build_phi_from_cnf(...)` namísto syntetického větvení `mode`.

> Tím se $\Phi$ stane **funkcí vstupní CNF**, a $\mu$ začne nést informaci o SAT vs. UNSAT.

# Který kód z repa je „nejblíž hotovému“

* **Skeleton, který lze nejrychleji dovést na funkční SAT tester**: právě vaše **BOOM.PY** + Runner. Struktura je čistá a přehledná; stačí výše popsané napojení na DIMACS (a zahození „syntetických režimů“). &#x20;
* **Starší “FULL1\_\*”** mají bohatší dynamiku/annealing/noise-gate, ale jsou těžší na audit a replikaci. Doporučuji: nejdřív „pravdivý BOOM“ (deterministický rozhodovač nad CNF), pak teprve přimíchávat vaše pokročilé gates.

# Krátký checklist na důkazní sadu

1. UF20/50 (SAT) a UUF50/100 (UNSAT) – řádově tisíce instancí.
2. ROC křivky pro $\mu$ a „lock-only S2 row-sum“ → vybrat $\tau$.
3. Ablace: bez de-alias offsetů, bez col-stride, bez Hadamardu → ukázat propad margin.
4. Škálování: $C\in\{50,100,200,1000\}$, $R\sim c_R\log C$ – měřit čas a stabilitu power-method.

---

Chceš, abych ten skeleton upravil celý (parser + builder $\Phi$) a poslal jako “BOOM\_CNF.py” + drobný update runneru (přidat `--cnf PATH` a brát $C$ z dat)? Stačí říct – připravím verzi, která hned běží na satlib/ufxx/uufxx a produkuje $\mu$+S2 reporty v JSON.
